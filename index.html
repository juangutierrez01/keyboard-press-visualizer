<!DOCTYPE html>
<html>
  <head>
    <title>keyboard</title>
  </head>
  <body style="margin:0;overflow:hidden">
    <canvas style="display:block"></canvas>
    <script>
/****************************************************************************/
const canvas = document.querySelector("canvas");
const context = canvas.getContext("2d");

// Circular buffer queue to hold multiple key codes
// for the possibility of user pressing multiple
// keys within the time span of a single frame
const keyQueue = {
  data: new Array(16),
  start: 0,
  end: 0,
  push: function(value) {
    if ((this.end + 1) % this.data.length === this.start) {
      return;
    }

    this.data[this.end] = value;
    this.end = (this.end + 1) % this.data.length;
  },
  pop: function() {
    const poppedValue = this.data[this.start];
    this.start = (this.start + 1) % this.data.length;
    return poppedValue;
  }
};

// Spatial mapping of key codes to areas on the screen
const keyMap = new Map(
  [
    "1234567890"
      .split("")
      .map((digit) => "Digit" + digit)
      .concat(["Minus", "Equal", "Backspace"]),
    "QWERTYUIOP"
      .split("")
      .map((char) => "Key" + char)
      .concat(["BracketLeft", "BracketRight", "Backslash"]),
    "ASDFGHJKL"
      .split("")
      .map((char) => "Key" + char)
      .concat(["Semicolon", "Quote", "Enter"]),
    "ZXCVBNM"
      .split("")
      .map((char) => "Key" + char)
      .concat(["Comma", "Period", "Slash", "ShiftRight"]),
  ]
    .flatMap((row, rowIndex) => 
      row
        .map((key, keyIndex) =>
          [key, [keyIndex + 0.5*rowIndex, rowIndex, 1]]
        )
    )
);

["KeyQ", "KeyA", "KeyZ"].forEach((key, rowIndex) => {
  keyMap.get(key)[0] = 0;
  keyMap.get(key)[2] = 1.5 + 0.5*rowIndex;
});

keyMap.get("Backspace")[2] = 1.5;
keyMap.get("Enter")[2] = 1.5;
keyMap.get("ShiftRight")[2] = 2;

const KEY_ROWS = 13.5;
const KEY_COLUMNS = 4;

// Add detected keys to key queue
window.addEventListener("keydown", (event) => {
  if (keyMap.has(event.code)) {
    keyQueue.push(event.code);
  }
});

// React to dark/light mode
let backgroundColor = "rgb(255 255 255 / 8%)";
let keyColor = "black";

window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (function toggleDarkMode(event) {
  backgroundColor = event.matches ? "rgb(0 0 0 / 8%)" : "rgb(255 255 255 / 8%)";
  keyColor = event.matches ? "white" : "black";
  return toggleDarkMode;
})(window.matchMedia("(prefers-color-scheme: dark)")));

// Resize canvas when page is resized
window.addEventListener("resize", (function resizeCanvas() {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
    
    // Initialize the background color to prevent
    // drawn keys from leaving a permanent shadow
    context.fillStyle = keyColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = backgroundColor;
    for (let i = 0; i < 64; ++i) {
      context.fillRect(0, 0, canvas.width, canvas.height);
    }

    return resizeCanvas;
})());

// Display detected keys spatially to screen
window.requestAnimationFrame(function draw() {
  window.requestAnimationFrame(draw);

  // Fade the whole screen
  context.fillStyle = backgroundColor;
  context.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw any keys detected
  if (keyQueue.start !== keyQueue.end) {
    context.fillStyle = keyColor;

    do {
      const [x, y, w] = keyMap.get(keyQueue.pop()) ?? [-1, -1, 0];
      context.fillRect(
        x * canvas.width / KEY_ROWS,
        y * canvas.height / KEY_COLUMNS,
        w * canvas.width / KEY_ROWS,
        canvas.height / KEY_COLUMNS
      );
    } while (keyQueue.start !== keyQueue.end)
  }
});
/****************************************************************************/
    </script>
  </body>
</html>